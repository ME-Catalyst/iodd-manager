# Adapter Generation Guide

IODD Manager can generate platform-specific adapter code from IODD files, making it easy to integrate IO-Link devices into various systems.

## Supported Platforms

| Platform | Description | Output Format |
|----------|-------------|---------------|
| **Node-RED** | Visual programming for IoT | JSON flow |
| **Python** | Python device class | .py file |
| **C++** | C++ device class | .cpp/.h files |
| **Custom** | User-defined templates | Any format |

## Node-RED Adapters

### What is Generated

Node-RED adapters include:

- **Device Node**: Custom node for the IO-Link device
- **Configuration**: Device identity and parameters
- **Parameter Access**: Read/write functions for all parameters
- **Process Data**: Parsers for input/output data
- **Events**: Event handlers and notifications
- **UI Forms**: Configuration interface

### Generating Node-RED Adapter

**Via Web Interface:**

1. Navigate to device details
2. Click **"Generate Adapter"**
3. Select **"Node-RED"** platform
4. Choose options:
   - ☑ Include parameters
   - ☑ Include process data
   - ☐ Include events
5. Click **"Generate & Download"**
6. Save as `iolink-device-12345-67890.json`

**Via CLI:**

```bash
python iodd_manager.py generate 12345 67890 nodered \
  --include-params \
  --include-events \
  --output iolink-device.json
```

**Via API:**

```bash
curl -X POST http://localhost:8000/api/adapters/generate \
  -H "Content-Type: application/json" \
  -d '{
    "vendor_id": 12345,
    "device_id": 67890,
    "target_platform": "nodered",
    "options": {
      "include_parameters": true,
      "include_events": true
    }
  }' \
  --output iolink-device.json
```

### Generated Structure

```json
[
  {
    "id": "iolink_device_12345_67890",
    "type": "io-link-device",
    "name": "Temperature Sensor",
    "vendorId": 12345,
    "deviceId": 67890,
    "parameters": {
      "operatingMode": {
        "index": 1,
        "access": "rw",
        "type": "UInt8",
        "default": 0,
        "enum": {
          "0": "Off",
          "1": "Normal",
          "2": "Advanced"
        }
      }
    },
    "processDataIn": {
      "length": 4,
      "structure": [
        {
          "name": "temperature",
          "type": "Int16",
          "offset": 0,
          "unit": "°C",
          "scale": 0.1
        }
      ]
    },
    "processDataOut": {
      "length": 2,
      "structure": [
        {
          "name": "setpoint",
          "type": "UInt8",
          "offset": 0
        }
      ]
    },
    "events": [
      {
        "code": "0x8000",
        "name": "Temperature Too High",
        "severity": "error"
      }
    ]
  }
]
```

### Importing into Node-RED

1. Open Node-RED (http://localhost:1880)
2. Click **Menu** (≡) → **Import**
3. Click **"select a file to import"**
4. Choose generated JSON file
5. Click **Import**
6. Deploy the flow

### Using in Node-RED

Example flow:

```
[IO-Link Master] → [Temperature Sensor] → [Debug]
                         ↓
                    [Dashboard]
```

**Reading Process Data:**

```javascript
// In function node
msg.temperature = msg.payload.processDataIn.temperature;
msg.unit = "°C";
return msg;
```

**Writing Parameters:**

```javascript
// Set operating mode
msg.payload = {
  parameter: "operatingMode",
  value: 1  // Normal
};
return msg;
```

## Python Adapters

### What is Generated

Python adapters include:

- **Device Class**: Object-oriented device interface
- **Type Hints**: Full type annotations
- **Properties**: Parameter accessors
- **Methods**: Parameter read/write functions
- **Data Classes**: Process data structures
- **Enumerations**: Enum types for parameters
- **Documentation**: Docstrings for all members

### Generating Python Adapter

**Via CLI:**

```bash
python iodd_manager.py generate 12345 67890 python \
  --output temperature_sensor.py
```

**Via API:**

```bash
curl -X POST http://localhost:8000/api/adapters/generate \
  -H "Content-Type: application/json" \
  -d '{
    "vendor_id": 12345,
    "device_id": 67890,
    "target_platform": "python"
  }' \
  --output temperature_sensor.py
```

### Generated Code Structure

```python
"""
Temperature Sensor - IO-Link Device Adapter
Vendor: ifm electronic (12345)
Device: Temperature Sensor (67890)

Auto-generated by IODD Manager
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional
import struct


class OperatingMode(Enum):
    """Device operating mode"""
    OFF = 0
    NORMAL = 1
    ADVANCED = 2
    DIAGNOSTIC = 3


@dataclass
class ProcessDataIn:
    """Process data from device (4 bytes)"""
    temperature: float  # °C, Int16, scale 0.1
    pressure: int  # bar, UInt8
    alarm: bool  # Boolean

    @classmethod
    def parse(cls, data: bytes) -> 'ProcessDataIn':
        """Parse raw process data"""
        if len(data) != 4:
            raise ValueError(f"Expected 4 bytes, got {len(data)}")

        temperature_raw = struct.unpack('>h', data[0:2])[0]
        temperature = temperature_raw * 0.1

        pressure = data[2]
        alarm = bool(data[3] & 0x01)

        return cls(
            temperature=temperature,
            pressure=pressure,
            alarm=alarm
        )


@dataclass
class ProcessDataOut:
    """Process data to device (2 bytes)"""
    setpoint: int  # UInt8
    enable: bool  # Boolean

    def serialize(self) -> bytes:
        """Serialize to raw bytes"""
        data = bytearray(2)
        data[0] = self.setpoint
        data[1] = 0x01 if self.enable else 0x00
        return bytes(data)


class TemperatureSensor:
    """
    IO-Link device adapter for Temperature Sensor

    Vendor: ifm electronic (12345)
    Device ID: 67890
    Version: 1.1.0
    """

    VENDOR_ID = 12345
    DEVICE_ID = 67890
    VERSION = "1.1.0"

    def __init__(self, io_link_master):
        """
        Initialize device adapter

        Args:
            io_link_master: IO-Link master interface
        """
        self.master = io_link_master
        self._operating_mode: Optional[OperatingMode] = None

    def read_parameter(self, index: int) -> bytes:
        """Read parameter by index"""
        return self.master.read_parameter(self.VENDOR_ID, self.DEVICE_ID, index)

    def write_parameter(self, index: int, value: bytes) -> None:
        """Write parameter by index"""
        self.master.write_parameter(self.VENDOR_ID, self.DEVICE_ID, index, value)

    @property
    def operating_mode(self) -> OperatingMode:
        """Get operating mode"""
        data = self.read_parameter(1)
        return OperatingMode(data[0])

    @operating_mode.setter
    def operating_mode(self, mode: OperatingMode) -> None:
        """Set operating mode"""
        self.write_parameter(1, bytes([mode.value]))

    def read_process_data_in(self) -> ProcessDataIn:
        """Read input process data from device"""
        data = self.master.read_process_data_in(self.VENDOR_ID, self.DEVICE_ID)
        return ProcessDataIn.parse(data)

    def write_process_data_out(self, data: ProcessDataOut) -> None:
        """Write output process data to device"""
        raw_data = data.serialize()
        self.master.write_process_data_out(self.VENDOR_ID, self.DEVICE_ID, raw_data)

    def get_temperature(self) -> float:
        """Get current temperature in °C"""
        process_data = self.read_process_data_in()
        return process_data.temperature

    def set_setpoint(self, value: int) -> None:
        """Set temperature setpoint"""
        data = ProcessDataOut(setpoint=value, enable=True)
        self.write_process_data_out(data)


# Example usage
if __name__ == "__main__":
    from io_link_master import IOLinkMaster

    # Initialize master
    master = IOLinkMaster(port="/dev/ttyUSB0")

    # Create device instance
    sensor = TemperatureSensor(master)

    # Read temperature
    temp = sensor.get_temperature()
    print(f"Temperature: {temp}°C")

    # Set operating mode
    sensor.operating_mode = OperatingMode.NORMAL

    # Read process data
    data = sensor.read_process_data_in()
    print(f"Temp: {data.temperature}°C, Pressure: {data.pressure} bar")

    # Set setpoint
    sensor.set_setpoint(25)
```

### Using Python Adapter

```python
from temperature_sensor import TemperatureSensor, OperatingMode
from your_iolink_library import IOLinkMaster

# Connect to IO-Link master
master = IOLinkMaster(host="192.168.1.100", port=502)

# Create device instance
sensor = TemperatureSensor(master)

# Configure device
sensor.operating_mode = OperatingMode.NORMAL

# Read data
temperature = sensor.get_temperature()
print(f"Current temperature: {temperature}°C")

# Read full process data
data = sensor.read_process_data_in()
print(f"Temperature: {data.temperature}°C")
print(f"Pressure: {data.pressure} bar")
print(f"Alarm: {data.alarm}")

# Write data
sensor.set_setpoint(25)
```

## C++ Adapters

### What is Generated

C++ adapters include:

- **Header File** (`.h`): Class declaration
- **Implementation File** (`.cpp`): Class definition
- **Type-Safe Interface**: Strong typing
- **Process Data Structures**: Packed structs
- **Parameter Accessors**: Getter/setter methods
- **Documentation**: Doxygen comments

### Generating C++ Adapter

```bash
python iodd_manager.py generate 12345 67890 cpp \
  --output temperature_sensor
```

Generates:

- `temperature_sensor.h`
- `temperature_sensor.cpp`

### Generated Header (`temperature_sensor.h`)

```cpp
/**
 * @file temperature_sensor.h
 * @brief IO-Link device adapter for Temperature Sensor
 *
 * Vendor: ifm electronic (12345)
 * Device ID: 67890
 * Version: 1.1.0
 *
 * Auto-generated by IODD Manager
 */

#ifndef TEMPERATURE_SENSOR_H
#define TEMPERATURE_SENSOR_H

#include <cstdint>
#include <vector>

namespace iolink {

/**
 * @brief Operating mode enumeration
 */
enum class OperatingMode : uint8_t {
    OFF = 0,
    NORMAL = 1,
    ADVANCED = 2,
    DIAGNOSTIC = 3
};

/**
 * @brief Process data input structure (4 bytes)
 */
struct ProcessDataIn {
    int16_t temperature;  ///< Temperature in 0.1°C
    uint8_t pressure;     ///< Pressure in bar
    bool alarm;           ///< Alarm flag

    /**
     * @brief Parse from raw bytes
     * @param data Raw byte array
     * @param length Data length (must be 4)
     * @return Parsed structure
     */
    static ProcessDataIn parse(const uint8_t* data, size_t length);

    /**
     * @brief Get temperature in °C
     * @return Temperature value
     */
    float getTemperatureC() const {
        return temperature * 0.1f;
    }
} __attribute__((packed));

/**
 * @brief Process data output structure (2 bytes)
 */
struct ProcessDataOut {
    uint8_t setpoint;  ///< Setpoint value
    bool enable;       ///< Enable flag

    /**
     * @brief Serialize to raw bytes
     * @return Byte vector
     */
    std::vector<uint8_t> serialize() const;
} __attribute__((packed));

/**
 * @brief Temperature Sensor device adapter
 */
class TemperatureSensor {
public:
    static constexpr uint16_t VENDOR_ID = 12345;
    static constexpr uint16_t DEVICE_ID = 67890;
    static constexpr const char* VERSION = "1.1.0";

    /**
     * @brief Constructor
     * @param master IO-Link master interface
     */
    explicit TemperatureSensor(IOLinkMaster& master);

    /**
     * @brief Get operating mode
     * @return Current operating mode
     */
    OperatingMode getOperatingMode();

    /**
     * @brief Set operating mode
     * @param mode New operating mode
     */
    void setOperatingMode(OperatingMode mode);

    /**
     * @brief Read input process data
     * @return Process data structure
     */
    ProcessDataIn readProcessDataIn();

    /**
     * @brief Write output process data
     * @param data Process data structure
     */
    void writeProcessDataOut(const ProcessDataOut& data);

    /**
     * @brief Get current temperature
     * @return Temperature in °C
     */
    float getTemperature();

    /**
     * @brief Set temperature setpoint
     * @param value Setpoint value
     */
    void setSetpoint(uint8_t value);

private:
    IOLinkMaster& master_;

    std::vector<uint8_t> readParameter(uint8_t index);
    void writeParameter(uint8_t index, const std::vector<uint8_t>& data);
};

} // namespace iolink

#endif // TEMPERATURE_SENSOR_H
```

### Using C++ Adapter

```cpp
#include "temperature_sensor.h"
#include "io_link_master.h"
#include <iostream>

int main() {
    // Connect to IO-Link master
    iolink::IOLinkMaster master("/dev/ttyUSB0");

    // Create device instance
    iolink::TemperatureSensor sensor(master);

    // Configure device
    sensor.setOperatingMode(iolink::OperatingMode::NORMAL);

    // Read temperature
    float temp = sensor.getTemperature();
    std::cout << "Temperature: " << temp << "°C" << std::endl;

    // Read process data
    auto data = sensor.readProcessDataIn();
    std::cout << "Temperature: " << data.getTemperatureC() << "°C" << std::endl;
    std::cout << "Pressure: " << (int)data.pressure << " bar" << std::endl;
    std::cout << "Alarm: " << (data.alarm ? "Yes" : "No") << std::endl;

    // Set setpoint
    sensor.setSetpoint(25);

    return 0;
}
```

## Custom Adapters

### Template System

Create custom adapters using Jinja2 templates.

### Creating a Template

Create `my_template.j2`:

```jinja2
// Device: {{ device.device_name }}
// Vendor: {{ device.vendor_name }} ({{ device.vendor_id }})
// Device ID: {{ device.device_id }}

{% for param in parameters %}
// Parameter {{ param.index }}: {{ param.name }}
//   Type: {{ param.data_type }}
//   Access: {{ param.access }}
//   Default: {{ param.default_value }}
{% endfor %}

const deviceConfig = {
  vendorId: {{ device.vendor_id }},
  deviceId: {{ device.device_id }},
  name: "{{ device.device_name }}",
  parameters: {
    {% for param in parameters %}
    {{ param.name | lower | replace(' ', '_') }}: {
      index: {{ param.index }},
      type: "{{ param.data_type }}",
      default: {{ param.default_value }}
    }{% if not loop.last %},{% endif %}
    {% endfor %}
  }
};
```

### Generating with Custom Template

```bash
python iodd_manager.py generate 12345 67890 custom \
  --template my_template.j2 \
  --output device_config.js
```

### Available Template Variables

| Variable | Description |
|----------|-------------|
| `device.vendor_id` | Vendor ID |
| `device.device_id` | Device ID |
| `device.vendor_name` | Vendor name |
| `device.device_name` | Device name |
| `device.version` | IODD version |
| `device.product_text` | Description |
| `parameters` | List of parameters |
| `process_data_in` | Input process data structure |
| `process_data_out` | Output process data structure |
| `events` | List of events |

### Parameter Object

```python
{
  "index": 1,
  "name": "Operating Mode",
  "access": "rw",  # ro, wo, rw
  "data_type": "UInt8",
  "length": 1,
  "default_value": "0",
  "min_value": "0",
  "max_value": "3",
  "unit": null,
  "description": "Selects device operating mode",
  "enum_values": {
    "0": "Off",
    "1": "Normal"
  }
}
```

## Best Practices

### Version Control

Store generated adapters in version control:

```bash
git add generated/temperature_sensor.py
git commit -m "Add adapter for Temperature Sensor v1.1.0"
```

### Naming Conventions

Use consistent names:

```
nodered_<vendor>_<device>_v<version>.json
python_<vendor>_<device>_v<version>.py
cpp_<vendor>_<device>_v<version>.{h,cpp}
```

### Documentation

Document any modifications:

```python
"""
Temperature Sensor Adapter

Auto-generated by IODD Manager
Generated: 2025-01-11

MODIFICATIONS:
- Added custom calibration function (2025-01-12)
- Updated error handling (2025-01-13)
"""
```

### Testing

Always test generated adapters:

```python
import unittest
from temperature_sensor import TemperatureSensor, ProcessDataIn

class TestTemperatureSensor(unittest.TestCase):
    def test_process_data_parsing(self):
        data = bytes([0x00, 0xFA, 0x05, 0x01])
        result = ProcessDataIn.parse(data)
        self.assertEqual(result.temperature, 25.0)
        self.assertEqual(result.pressure, 5)
        self.assertTrue(result.alarm)
```

## Troubleshooting

### Generation Fails

Check device exists:

```bash
python iodd_manager.py show 12345 67890
```

### Invalid Template

Validate template syntax:

```bash
python -c "from jinja2 import Template; Template(open('template.j2').read())"
```

### Missing Parameters

Check parameter count:

```bash
python iodd_manager.py show 12345 67890 --parameters
```

## Next Steps

- **[Web Interface](web-interface.md)** - Generate via web UI
- **[CLI Usage](cli.md)** - Generate via command line
- **[API Guide](api.md)** - Generate via API
- **[Developer Guide](../developer-guide/architecture.md)** - Extend generation
